<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="UTF-8">
  <meta 
    name="viewport"
    content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
  <meta 
    http-equiv="X-UA-Compatible" 
    content="ie=edge">
  <meta 
    name="theme-color" 
    content="#fff" 
    id="theme-color">
  <meta 
    name="description" 
    content="Hexo">
  <link 
    rel="icon" 
    href="/img/catton.jpg">
  <title>04 类的重用</title>
  
    
      <meta 
        property="og:title" 
        content="04 类的重用">
    
    
      <meta 
        property="og:url" 
        content="http://example.com/2021/08/05/04-%E7%B1%BB%E7%9A%84%E9%87%8D%E7%94%A8/index.html">
    
    
      <meta 
        property="og:img" 
        content="img/catton.jpg">
    
    
    
      <meta 
        property="og:type" 
        content="article">
      <meta 
        property="og:article:published_time" 
        content="2021-08-05">
      <meta 
        property="og:article:modified_time" 
        content="2021-08-05">
      <meta 
        property="og:article:author" 
        content="xuehongfei">
      
        
      
    
  
  <script>
    function loadScript(url, cb) {
      var script = document.createElement('script');
      script.src = url;
      if (cb) script.onload = cb;
      script.async = true;
      document.body.appendChild(script);
    }
    function loadCSS(href, data, attr) {
      var sheet = document.createElement('link');
      sheet.ref = 'stylesheet';
      sheet.href = href;
      sheet.dataset[data] = attr;
      document.head.appendChild(sheet);
    }
    function changeCSS(cssFile, data, attr) {
      var oldlink = document.querySelector(data);
      var newlink = document.createElement("link");
      newlink.setAttribute("rel", "stylesheet");
      newlink.setAttribute("href", cssFile);
      newlink.dataset.prism = attr;
      document.head.replaceChild(newlink, oldlink);
    }
  </script>
  
    
  
  <script>
    // control reverse button
    var reverseDarkList = {
      dark: 'light',
      light: 'dark'
    };
    var themeColor = {
      dark: '#1c1c1e',
      light: '#fff'
    }
    // get the data of css prefers-color-scheme
    var getCssMediaQuery = function() {
      return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    };
    // reverse current darkmode setting function
    var reverseDarkModeSetting = function() {
      var setting = localStorage.getItem('user-color-scheme');
      if(reverseDarkList[setting]) {
        setting = reverseDarkList[setting];
      } else if(setting === null) {
        setting = reverseDarkList[getCssMediaQuery()];
      } else {
        return;
      }
      localStorage.setItem('user-color-scheme', setting);
      return setting;
    };
    // apply current darkmode setting
  </script>
  
    <script>
      var setDarkmode = function(mode) {
      var setting = mode || localStorage.getItem('user-color-scheme');
      if(setting === getCssMediaQuery()) {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[setting];
        document.getElementById('theme-color').dataset.mode = setting;
      } else if(reverseDarkList[setting]) {
        document.documentElement.setAttribute('data-user-color-scheme', setting);
        document.getElementById('theme-color').content = themeColor[setting];
        document.getElementById('theme-color').dataset.mode = setting;
      } else {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[getCssMediaQuery()];
        document.getElementById('theme-color').dataset.mode = getCssMediaQuery();
      }
    };
    setDarkmode();
    </script>
  
  
  <link rel="preload" href="//at.alicdn.com/t/font_1946621_i1kgafibvw.css" as="style" >
  <link rel="preload" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css" as="style" >
  
  
    <link rel="preload" href="/js/lib/lightbox/baguetteBox.min.js" as="script">
    <link rel="preload" href="/js/lib/lightbox/baguetteBox.min.css" as="style" >
  
  
    <link rel="preload" href="/js/lib/lozad.min.js" as="script">
  
  
  
  
  
  
  
  <link rel="stylesheet" href="/css/main.css">
  
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1946621_i1kgafibvw.css">
  
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css">
  
    <link rel="stylesheet" href="/js/lib/lightbox/baguetteBox.min.css">
  
<meta name="generator" content="Hexo 5.4.0"></head>

  <body>
    <div class="wrapper">
       
      <nav class="navbar">
  <div class="navbar-logo">
    <span class="navbar-logo-main">
      
        <img 
          class="navbar-logo-img"
          width="32"
          height="32"
          src="/img/catton.jpg" 
          alt="blog logo">
      
      <span class="navbar-logo-dsc">Mr.Xue's Blog</span>
    </span>
  </div>
  <div class="navbar-menu">
    
      <a 
        href="/" 
        class="navbar-menu-item">
        
          Home
        
      </a>
    
      <a 
        href="/archives" 
        class="navbar-menu-item">
        
          Archive
        
      </a>
    
      <a 
        href="/tags" 
        class="navbar-menu-item">
        
          Tags
        
      </a>
    
      <a 
        href="/categories" 
        class="navbar-menu-item">
        
          Categories
        
      </a>
    
      <a 
        href="/about" 
        class="navbar-menu-item">
        
          About
        
      </a>
    
      <a 
        href="/links" 
        class="navbar-menu-item">
        
          Friends
        
      </a>
    
    <a 
      class="navbar-menu-item darknavbar" 
      id="dark">
      <i class="iconfont icon-weather"></i>
    </a>
    <a 
      class="navbar-menu-item searchnavbar" 
      id="search">
      <i 
        class="iconfont icon-search" 
        style="font-size: 1.2rem; font-weight: 400;">
      </i>
    </a>
  </div>
</nav> 
      
      <div 
        id="local-search" 
        style="display: none">
        <input
          class="navbar-menu-item"
          id="search-input"
          placeholder="请输入搜索内容..." />
        <div id="search-content"></div>
      </div>
      
      <div class="section-wrap">
        <div class="container">
          <div class="columns">
            <main class="main-column">
<article class="card card-content">
  <header>
    <h1 class="post-title">
      04 类的重用
    </h1>
  </header>
  <div class="post-meta post-show-meta">
    <time datetime="2021-08-05T01:30:40.429Z">
      <i 
        class="iconfont icon-calendar" 
        style="margin-right: 2px;">
      </i>
      <span>2021-08-05</span>
    </time>
    
    
      <span class="dot"></span>
      <span>6.8k words</span>
    
  </div>
  
  </header>
  <div 
    id="section" 
    class="post-content">
    <h1 id="第四章-类的重用"><a href="#第四章-类的重用" class="headerlink" title="第四章 类的重用"></a>第四章 类的重用</h1><h2 id="一、类的继承"><a href="#一、类的继承" class="headerlink" title="一、类的继承"></a>一、类的继承</h2><p>类的继承</p>
<p>一种由已有的类创建新类的机制，是面向对象程序设计的基石之一</p>
<p>通过继承，可以根据已有类来定义新类，新类拥有已有类的所有功能</p>
<p>Java只支持类的单继承，每个子类只能有一个直接父类</p>
<p>父类是所有子类的公共属性及方法的集合，子类则是父类的特殊化</p>
<p>继承机制可以提高程序的抽象程度，提高代码的可重用性</p>
<h3 id="1-继承的概念"><a href="#1-继承的概念" class="headerlink" title="1.继承的概念"></a>1.继承的概念</h3><h4 id="基类和派生类"><a href="#基类和派生类" class="headerlink" title="基类和派生类"></a>基类和派生类</h4><p>基类</p>
<p>也称超类，是被直接或间接继承的类</p>
<p>派生类</p>
<p>也称子类，继承其他类而得到的类，继承所有祖先的状态和行为，派生类可以增加变量和方法，派生类也可以覆盖继承的方法。</p>
<p>is_a关系</p>
<p>子类对象与父类对象存在“IS A”（或“is a kind of”）的关系</p>
<img src="D:\我的文件\Java课件\第四章 类的重用.assets\image-20210520145613104.png" alt="image-20210520145613104" style="zoom:50%;" / srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="D:\我的文件\Java课件\第四章 类的重用.assets\image-20210520145613104.png" class="lozad post-image">

<h4 id="派生类对象"><a href="#派生类对象" class="headerlink" title="派生类对象"></a>派生类对象</h4><p>派生类产生的对象</p>
<p>从外部来看，它应该包括：与基类相同的接口；可以具有更多的方法和数据成员</p>
<p>其内包含着一个基类类型的子对象</p>
<h3 id="2-继承的语法"><a href="#2-继承的语法" class="headerlink" title="2.继承的语法"></a>2.继承的语法</h3><p>继承的语法</p>
<p><code>class childClass extends parentClass&#123;//类体&#125;</code></p>
<p>子类不能直接访问从父类中继承的<strong>私有属性及方法</strong>，但可使用<strong>公有（及保护）方法</strong>进行访问。</p>
<img src="D:\我的文件\Java课件\第四章 类的重用.assets\image-20210520150411174.png" alt="image-20210520150411174" style="zoom:67%;" / srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="D:\我的文件\Java课件\第四章 类的重用.assets\image-20210520150411174.png" class="lozad post-image">

<h3 id="3-隐藏和覆盖"><a href="#3-隐藏和覆盖" class="headerlink" title="3.隐藏和覆盖"></a>3.隐藏和覆盖</h3><p>子类对从父类继承来的属性变量及方法可以<strong>重新定义</strong></p>
<h4 id="属性的隐藏"><a href="#属性的隐藏" class="headerlink" title="属性的隐藏"></a>属性的隐藏</h4><img src="D:\我的文件\Java课件\第四章 类的重用.assets\image-20210520150518517.png" alt="image-20210520150518517" style="zoom:80%;" / srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="D:\我的文件\Java课件\第四章 类的重用.assets\image-20210520150518517.png" class="lozad post-image">

<p>子类中声明了与父类中相同的成员变量名，则从父类继承的变量将被隐藏。</p>
<p>子类拥有了两个相同名字的变量，一个继承自父类，另一个继承由自己声明</p>
<p>当子类执行继承自<strong>父类的操作时</strong>，处理的是继承自<strong>父类的变量</strong>，而当子类执行它<strong>自己声明</strong>的方法时，所操作的就是它<strong>自己声明</strong>的变量。</p>
<h4 id="访问被隐藏的父类属性"><a href="#访问被隐藏的父类属性" class="headerlink" title="访问被隐藏的父类属性"></a>访问被隐藏的父类属性</h4><p>如何访问被隐藏的父类属性</p>
<p>调用从父类继承的方法，则操作的是从父类继承的属性；</p>
<p><strong>使用super.属性</strong></p>
<img src="D:\我的文件\Java课件\第四章 类的重用.assets\image-20210520151505445.png" alt="image-20210520151505445" style="zoom: 67%;" / srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="D:\我的文件\Java课件\第四章 类的重用.assets\image-20210520151505445.png" class="lozad post-image">

<img src="D:\我的文件\Java课件\第四章 类的重用.assets\image-20210520151543932.png" alt="image-20210520151543932" style="zoom:67%;" / srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="D:\我的文件\Java课件\第四章 类的重用.assets\image-20210520151543932.png" class="lozad post-image">

<h4 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h4><img src="D:\我的文件\Java课件\第四章 类的重用.assets\image-20210520151725899.png" alt="image-20210520151725899" style="zoom:67%;" / srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="D:\我的文件\Java课件\第四章 类的重用.assets\image-20210520151725899.png" class="lozad post-image">

<h4 id="方法覆盖"><a href="#方法覆盖" class="headerlink" title="方法覆盖"></a>方法覆盖</h4><p>方法覆盖</p>
<ul>
<li>如果子类不需使用从父类继承来的方法的功能，则可以声明自己的同名方法，称为方法覆盖</li>
<li>覆盖方法的<strong>返回类型，方法名称，参数的个数及类型</strong>必须和被覆盖的方法一模一样</li>
<li>覆盖方法的访问权限可以比被覆盖的宽松，但是不能更为严格</li>
</ul>
<p>方法覆盖的应用场合</p>
<ul>
<li>子类中实现与父类相同的功能，但采用不同的算法或公式</li>
<li>在名字相同的方法中，要做比父类更多的事情</li>
<li>在子类中需要取消从父类继承的方法</li>
<li><strong>父类private属性的方法不能被继承，因此也就不能被覆盖</strong></li>
</ul>
<p>方法覆盖实现运行时多态</p>
<ul>
<li>运行时多态是通过<strong>动态联编</strong>实现的。就是在运行时根据对象的实体类型确定对象的动作。</li>
</ul>
<img src="D:\我的文件\Java课件\第四章 类的重用.assets\image-20210520152358377.png" alt="image-20210520152358377" style="zoom: 50%;" / srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="D:\我的文件\Java课件\第四章 类的重用.assets\image-20210520152358377.png" class="lozad post-image">

<h3 id="4-有继承时的构造方法"><a href="#4-有继承时的构造方法" class="headerlink" title="4.有继承时的构造方法"></a>4.有继承时的构造方法</h3><p>有继承时的构造方法遵循以下的原则</p>
<ul>
<li>子类不能从父类继承构造方法</li>
<li>好的程序设计方法是在子类的构造方法中调用某一个父类构造方法，调用语句必须出现在子类构造方法的第一行，可使用<strong>super</strong>关键字</li>
<li>如子类构造方法的声明中没有明确调用父类构造方法，则系统在执行子类的构造方法时会自动调用父类的默认构造方法（即无参的构造方法）</li>
<li><strong>总之，无论如何，在创建子类对象时，从Object开始，其每一级基类的构造方法都会被执行</strong></li>
</ul>
<h3 id="5-继承举例"><a href="#5-继承举例" class="headerlink" title="5.继承举例"></a>5.继承举例</h3><h2 id="二、Object类"><a href="#二、Object类" class="headerlink" title="二、Object类"></a>二、Object类</h2><p>Java程序中所有类的直接或简洁父类，类库中所有类的父类，处在<strong>类层次最高点</strong></p>
<p>包含了所有Java类的公共属性，其构造方法时Object()</p>
<h3 id="包含的主要方法"><a href="#包含的主要方法" class="headerlink" title="包含的主要方法"></a>包含的主要方法</h3><p>object类定义了所有对象必须具有的状态和行为，较主要的方法如下</p>
<pre class="highlight"><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Class <span class="title">getClass</span><span class="params">()</span>	<span class="comment">//获取当前对象所属类的信息，返回Class对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span>		<span class="comment">//返回当前对象本身有关信息，按字符串对象返回</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span>	<span class="comment">//比较两个对象是否为同一对象，是则返回true</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span>		<span class="comment">//生成当前对象的一个拷贝，并返回这个复制对象</span></span></span><br><span class="line"><span class="function">Public <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span>			<span class="comment">//返回该对象的哈希代码值</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function">    	<span class="comment">//定义回收当前对象时所需要完成的资源释放工作</span></span></span><br></pre>

<p>你的类不可以覆盖终结方法，即有final修饰的方法</p>
<h3 id="相等和同一"><a href="#相等和同一" class="headerlink" title="相等和同一"></a>相等和同一</h3><p>相等和同一的概念</p>
<ul>
<li>两个对象具有<strong>相同的类型，及相同的属性值</strong>，则称二者<strong>相等</strong>（equal）</li>
<li>如果<strong>两个引用变量指向的是同一个对象</strong>，则称这两个变量（对象）<strong>同一</strong></li>
<li>两个对象同一，则一定相等</li>
<li>两个对象相等，不一定同一</li>
<li>比较运算符<strong>“==”</strong>判断的是这两个对象是否同一</li>
</ul>
<h3 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h3><p>由于Object是类层次结构中的树根节点，因此所有其他类都继承了equals()方法</p>
<p>Object类中的equals()方法定义如下，可见，也是判断两个对象是否同一：</p>
<p><code>public boolean equals(Object x)&#123; return this == x;&#125;</code></p>
<p>equals方法的重写</p>
<ul>
<li>要判断两个对象各个属性域的值是否相同，则不能使用从Object类继承来的equals方法，而需要在类声明中对equals方法进行重写</li>
<li>String类中已经重写了Object类的equals方法，可以判别两个字符串是否内容相同</li>
<li><img src="D:\我的文件\Java课件\第四章 类的重用.assets\image-20210520170535530.png" alt="image-20210520170535530" style="zoom:67%;" / srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="D:\我的文件\Java课件\第四章 类的重用.assets\image-20210520170535530.png" class="lozad post-image"></li>
</ul>
<h3 id="String-pool"><a href="#String-pool" class="headerlink" title="String pool"></a>String pool</h3><p>双引号中的字符串，作为特殊的对象保存在字符串池中。而且重复的字符串只会保存一份。</p>
<img src="D:\我的文件\Java课件\第四章 类的重用.assets\image-20210520171643665.png" alt="image-20210520171643665" style="zoom:67%;" / srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="D:\我的文件\Java课件\第四章 类的重用.assets\image-20210520171643665.png" class="lozad post-image">

<h3 id="clone方法"><a href="#clone方法" class="headerlink" title="clone方法"></a>clone方法</h3><p>根据已存在的对象构造一个新的对象</p>
<p>在跟类Object中被定义为protected，所以需要覆盖为public</p>
<p>实现Cloneable接口，赋予一个对象被克隆的能力</p>
<p><code>class MyObject implements Cloneable&#123;//...&#125;</code></p>
<h3 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize()方法"></a>finalize()方法</h3><p>在对象被垃圾回收器回收之前，系统自动调用对象的finalize方法</p>
<p>如果要覆盖finalize方法，覆盖方法的最后必须调用super.finalize</p>
<h3 id="getClass方法"><a href="#getClass方法" class="headerlink" title="getClass方法"></a>getClass方法</h3><p>final方法，返回一个Class对象，用来代表对象隶属的类</p>
<p>通过Class对象，你可以查询Class对象的各种信息：比如它的名字，它的基类，它所实现接口的名字等。</p>
<pre class="highlight"><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintClassName</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;The Object&#x27;s class is &quot;</span>+</span><br><span class="line">                      	obj.getClass().getName());</span><br><span class="line">&#125;</span><br></pre>

<h3 id="notify、notifyAll、wait方法"><a href="#notify、notifyAll、wait方法" class="headerlink" title="notify、notifyAll、wait方法"></a>notify、notifyAll、wait方法</h3><p>final方法，不能覆盖</p>
<p>这三个方法主要用在多线程程序中</p>
<h2 id="三、终结类与终结方法"><a href="#三、终结类与终结方法" class="headerlink" title="三、终结类与终结方法"></a>三、终结类与终结方法</h2><p>终结类与终结方法</p>
<p>被final修饰符修饰的类和方法</p>
<p>终结类<strong>不能被继承</strong></p>
<p>终结方法<strong>不能被当前类的子类重写</strong></p>
<h3 id="1-终结类"><a href="#1-终结类" class="headerlink" title="1.终结类"></a>1.终结类</h3><p>终结类的特点：不能有派生类</p>
<p>终结类存在的理由：</p>
<ul>
<li>安全：黑客用来搅乱系统的一个手法是建立一个类的派生类，然后用他们的类代替原来的类</li>
<li>设计：你认为你的类是最好的或从概念上你的类不应该有任何派生类</li>
</ul>
<h3 id="2-终结方法"><a href="#2-终结方法" class="headerlink" title="2.终结方法"></a>2.终结方法</h3><p>终结方法的特点：不能被派生类覆盖</p>
<p>终结方法存在的理由：</p>
<ul>
<li>对于一些比较重要且不希望子类进行更改的方法，可以声明为终结方法，可防止子类对父类关键方法的错误重写，增加了代码安全性和正确性。</li>
<li><strong>提高运行效率</strong>。通常，当Java运行环境（如Java解释器）运行方法时，它将首先在当前类中查找该方法，接下来在其超类中查找，并一直沿类层次向上查找，直到找到该方法为止。</li>
</ul>
<h3 id="Review-1"><a href="#Review-1" class="headerlink" title="Review"></a>Review</h3><p>方法的覆盖：运行时多态，后期绑定，运行时绑定</p>
<ul>
<li>final,static,private的方法不能被覆盖</li>
<li>运行时方法的查找</li>
</ul>
<p>有继承时的构造方法</p>
<ul>
<li>父类构造方法总是被执行：要么默认执行无参数构造方法；要么在子类构造方法第一个语句执行super(…)</li>
</ul>
<p>Object类以及equals方法，==运算符</p>
<p>String pool:</p>
<ul>
<li>对equals和==的影响</li>
</ul>
<p>final类和final方法：不能被继承和被覆盖</p>
<h2 id="四、抽象类"><a href="#四、抽象类" class="headerlink" title="四、抽象类"></a>四、抽象类</h2><p>抽象类</p>
<p>代表一个抽象概念的类</p>
<p>没有具体实例对象的类，不能使用new方法进行实例化</p>
<p>类前需加修饰符abstract</p>
<p><strong>可包含常规类能够包含的任何东西</strong>，例如构造方法，非抽象方法</p>
<p><strong>也可包含抽象方法</strong>，这种方法只有方法的声明，而没有方法的实现</p>
<p>存在意义</p>
<p>抽象类是类层次中较高层次的概括，抽象类的作用是让其他类来继承他的抽象化的特征</p>
<p>抽象类中可以包括被它的所有子类共享的公共行为</p>
<p>抽象类可以包括被它的所有子类共享的公共属性</p>
<p>在程序中不能用抽象类作为模板来创建对象</p>
<p>在用户生成实例时强迫用户生成更具体的实例，保证代码的安全性</p>
<h3 id="1-抽象类的声明"><a href="#1-抽象类的声明" class="headerlink" title="1.抽象类的声明"></a>1.抽象类的声明</h3><p>抽象类声明的语法形式为</p>
<p><code>abstract class Number&#123;...&#125;</code></p>
<p>如果写：<code>new Number();</code></p>
<p>编译器将显示错误</p>
<h3 id="2-抽象方法"><a href="#2-抽象方法" class="headerlink" title="2.抽象方法"></a>2.抽象方法</h3><p>声明的语法形式为：<code>public abstract &lt;returnType&gt; &lt;methodName&gt;(...);</code></p>
<p>仅<strong>有方法头，而没有方法体和操作实现</strong></p>
<p>具体实现由当前类的不同子类在它们各自的类声明中完成</p>
<p>抽象类可以包含抽象方法</p>
<h4 id="需注意的问题"><a href="#需注意的问题" class="headerlink" title="需注意的问题"></a>需注意的问题</h4><p>一个抽象类的子类若不是抽象类，则它必须为父类中的所有抽象方法书写方法体，即<strong>重写父类中的所有抽象方法</strong></p>
<p><strong>只有抽象类才能具有抽象方法</strong>，即如果一个类中含有抽象方法，则必须将这个类声明为抽象类</p>
<p>除了抽象方法，抽象类中还可以包含非抽象方法</p>
<h4 id="抽象方法的优点"><a href="#抽象方法的优点" class="headerlink" title="抽象方法的优点"></a>抽象方法的优点</h4><p><strong>隐藏具体的细节信息</strong>，所有的子类使用的都是相同的方法头，其中包含了调用该方法时需要了解的全部信息</p>
<p>强迫子类完成指定的行为，规定其子类需要用到的“标准”行为</p>
<h2 id="五、泛型"><a href="#五、泛型" class="headerlink" title="五、泛型"></a>五、泛型</h2><p>泛型是Java5的新特性，可以使Java语言变得更加简单、安全，其本质是参数化类型，即<strong>所操作的数据类型被指定为一个参数</strong></p>
<p>泛型即<strong>泛化技术</strong>，通过一种类型或方法操纵各种类型的对象，而同时又提供了编译时的类型安全保证。</p>
<p>泛型技术的基本思想是类和方法的泛化，是通过参数化实现的，因此泛型又被称为<strong>参数化类型</strong></p>
<p>优点：</p>
<ul>
<li>编译时的严格类型检查</li>
<li>消除了绝大多数的类型转换</li>
</ul>
<h3 id="1-泛型的概念"><a href="#1-泛型的概念" class="headerlink" title="1.泛型的概念"></a>1.泛型的概念</h3><p>泛型可以使用在类、接口以及方法的创建中，分别称为<strong>泛型类、泛型方法和泛型接口</strong></p>
<ul>
<li>泛型类：在类名后面加上“<Type>“</li>
<li>泛型方法：在方法名后面加上”<Type>“</li>
<li>泛型接口：第五章介绍接口时讲解</li>
</ul>
<p>使用泛型的优点：使Java语言变得更加简单、安全。</p>
<p>在没有泛型的情况下，通常通过对类型Object的引用来实现参数的“<strong>任意化</strong>”,”任意化“带来的缺点是必须做强制的类型转换。</p>
<ul>
<li>要求程序员预先知道实际的参数的类型</li>
<li>对于强制类型转换错误的情况，编译器可能不会提示错误，只在运行时才出现异常，从而在代码中存在安全隐患</li>
<li>或者程序员需要利用代码检查类型是否正确（instanceof，getClass）</li>
</ul>
<p>而在使用泛型的情况下，编译器会检查类型是否安全，并且所有的类型转换都是自动和隐式的，<u>可以提高代码的重用率。</u></p>
<p>一般使用一个大写字母表示参数类型约定如下：</p>
<ul>
<li>E - Element（Java Collections框架大量使用）</li>
<li>K - Key</li>
<li>N - Number</li>
<li>T - Type</li>
<li>V - Value</li>
<li>S,U,V等 - 第二，第三，第四个类型</li>
</ul>
<p>在Java5之前，为了让类具有通用性，往往将属性类型、函数参数、返回类型定义为Object的类</p>
<pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GeneralType</span> </span>&#123;</span><br><span class="line">	Object object;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">GeneralType</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.object = object;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getObj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> object;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tester</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        GeneralType i = <span class="keyword">new</span> GeneralType(<span class="number">2</span>); <span class="comment">// 传递参数为int类型的2，会自动封箱为Integer类型的对象。</span></span><br><span class="line">        GeneralType d = <span class="keyword">new</span> GeneralType(<span class="number">0.33</span>); <span class="comment">// 传递参数为double类型的0.33，会自动封箱为Double类型的对象。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;i.object=&quot;</span> + (Integer)i.getObj());</span><br><span class="line">        System.out.println(<span class="string">&quot;i.object=&quot;</span> + (Integer)d.getObj()); </span><br><span class="line">        <span class="comment">//可以通过编译，但运行时异常</span></span><br><span class="line">        <span class="comment">//java.lang.ClassCastException: java.lang.Double cannot be cast to java.lang.Integer at Tester.main(Tester.java:15)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>

<p>泛型类的使用</p>
<pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GeneralMethod</span> </span>&#123;</span><br><span class="line">    &lt;Type&gt; <span class="function"><span class="keyword">void</span> <span class="title">printClassName</span><span class="params">(Type object)</span> </span>&#123;</span><br><span class="line">        System.out.println(object.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GeneralMethod gm = <span class="keyword">new</span> GeneralMethod();</span><br><span class="line">        gm.printClassName(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        gm.printClassName(<span class="number">3</span>);</span><br><span class="line">        gm.printClassName(<span class="number">3.0f</span>);</span><br><span class="line">        gm.printClassName(<span class="number">3.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>

<h3 id="2-通配符泛型和有限制的泛型"><a href="#2-通配符泛型和有限制的泛型" class="headerlink" title="2.通配符泛型和有限制的泛型"></a>2.通配符泛型和有限制的泛型</h3><p>为了了解通用符泛型的作用，先尝试一下下面的代码是否合法：</p>
<pre class="highlight"><span class="line">class ShowType &#123;</span><br><span class="line">    public void showType(GeneralType&lt;Object&gt; o) &#123;</span><br><span class="line">    System.out.println(o.getObj().getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">public class Test &#123; </span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">    ShowType st = new ShowType();</span><br><span class="line">    GeneralType &lt;Integer&gt; i = new GeneralType &lt;Integer&gt; (2);</span><br><span class="line">    st.showType(i); //这行语句是否合法？</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>

<p>上面的代码并不能通过编译，这是因为不能将 General<Integer>类型的变量当做参数传递给General<Object></p>
<p>事实上，这里能传递的类型是能是General<Object>。因此，在使用泛型时应该注意和继承类的区别。</p>
<p>使用通配符泛型可以让showType函数发挥应有的作用</p>
<p>”？“代表任意一种类型，它被称为<strong>通配符</strong></p>
<p>有限制的泛型</p>
<ul>
<li>有时候需要将泛型中参数代表的类型做限制，此时就可以使用有限制的泛型</li>
<li>有限制的泛型是指，在参数”Type“后面使用”extends“关键字并加上类名或接口名，表明参数所代表的类型必须是改变的关键字或者实现了该接口。<ul>
<li>注意，对于实现了某接口的有限制的泛型，也是使用extends关键字，而不是implements关键字</li>
</ul>
</li>
</ul>
<h2 id="六、类的组合"><a href="#六、类的组合" class="headerlink" title="六、类的组合"></a>六、类的组合</h2><p>面向对象编程的一个重要思想就是用软件对象来模仿现实世界的对象</p>
<ul>
<li>现实世界中，大多数对象由更小的对象组成</li>
<li>与现实世界的对象一样，软件中的对象也常常是由更小的对象组成</li>
</ul>
<p><strong>Java类中可以有其他类的对象作为成员</strong>，这便是组合</p>
<h3 id="1-组合的语法"><a href="#1-组合的语法" class="headerlink" title="1.组合的语法"></a>1.组合的语法</h3><p>组合的语法很简单，只要把已存在类的对象放到新类中即可</p>
<p>可以使用”has a”语句来描述这种关系</p>
<img src="D:\我的文件\Java课件\第四章 类的重用.assets\image-20210520200422852.png" alt="image-20210520200422852" style="zoom:67%;" / srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="D:\我的文件\Java课件\第四章 类的重用.assets\image-20210520200422852.png" class="lozad post-image">

<h3 id="2-组合与继承的比较"><a href="#2-组合与继承的比较" class="headerlink" title="2.组合与继承的比较"></a>2.组合与继承的比较</h3><p>“包含”关系用组合来表达</p>
<ul>
<li>如果想利用新类内部一个现有类的特性，而不想使用它的接口， 通常应选择组合，我们需在新类里嵌入现有类的<strong>private对象</strong></li>
<li>如果想让类用户直接访问新类的组合成分，需要将成员对象的属性变为public</li>
</ul>
<p>“属于”关系用继承来表达</p>
<ul>
<li>取得一个现成的类，并制作它的一个特殊版本。通常，这意味着我们准备使用一个常规用途的类，并根据特定需求对其进行定制</li>
</ul>
<h3 id="3-组合与继承的结合"><a href="#3-组合与继承的结合" class="headerlink" title="3.组合与继承的结合"></a>3.组合与继承的结合</h3><p>许多时候都要求将组合与继承两种技术结合起来使用，创建一个更复杂的类</p>
<h3 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h3><p>1.单一职责原则    每一个类应该专注于做一件事情</p>
<p>2.里氏替换原则    超类存在的地方，子类是可以替换的</p>
<p>3.依赖倒置原则    <strong>实现尽量依赖抽象，不依赖具体实现</strong>（具体的就是依赖于抽象类或者接口）</p>
<p>4.接口隔离原则    应当为客户端提供尽可能小的单独的接口，而不是提供大的总的接口</p>
<p>5.迪米特法则        又叫做最少知识原则，一个软件实体应当尽可能少的与其他实体发生相互作用</p>
<p>6.开闭原则            面向扩展开放，面向修改关闭</p>
<p>7.组合/聚合复用原则    <strong>尽量使用合成/聚合达到复用，尽量少用继承</strong></p>
<p><strong>总之：尽可能做到高内聚、低耦合。</strong></p>
<h2 id="七、包的应用"><a href="#七、包的应用" class="headerlink" title="七、包的应用"></a>七、包的应用</h2><p>为了解决类名冲突，Java提供包来管理类名空 间</p>
<p>Java利用包来组织相关的类，并控制访问权限</p>
<p>包是一种松散的类的集合，利用包来管理类，可实现类的共享与复用</p>
<p>同一包中的类在默认情况下可以互相访问，通常把需要在一起工作的类放在一个包里</p>
<h3 id="1-Java基础类库"><a href="#1-Java基础类库" class="headerlink" title="1.Java基础类库"></a>1.Java基础类库</h3><p>Java提供了用于语言开发的类库，称为Java基础类库（JFC，java Foundational Class)，也称为应用程序编程接口（API），分别放在不同的包中</p>
<p>Java提供的包主要有 <code>java.lang,java.io,java.math,java.util,java.applet,java.awt,java.awt.image,</code></p>
<p><code>java.beans,java.net,java.rmi,java.security,java.sql等</code></p>
<h4 id="语言包（java-lang"><a href="#语言包（java-lang" class="headerlink" title="语言包（java.lang)"></a>语言包（java.lang)</h4><p>语言包提供了Java最基础的类，包括</p>
<ul>
<li>Object类</li>
<li>数据类型包裹类</li>
<li>字符串类</li>
<li>数学类</li>
<li>系统和运行时类</li>
<li>类操作类</li>
</ul>
<h4 id="数据类型包裹类"><a href="#数据类型包裹类" class="headerlink" title="数据类型包裹类"></a>数据类型包裹类</h4><p>对应Java的每一个基本数据类型都有一个数据包裹类</p>
<p>每个包裹类都只有一个类型为对应的基本数据类型的属性域</p>
<img src="D:\我的文件\Java课件\第四章 类的重用.assets\image-20210520202433579.png" alt="image-20210520202433579" style="zoom:80%;" / srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="D:\我的文件\Java课件\第四章 类的重用.assets\image-20210520202433579.png" class="lozad post-image">

<p><strong>生成数据类型包裹类对象的方法</strong></p>
<ul>
<li>从基本数据类型的变量或常量生成包裹类对象<ul>
<li><code>double x = 1.2; Double a = new Double(x); Double b = new Double(-5.25);</code></li>
</ul>
</li>
<li>从字符串生成包裹类对象<ul>
<li><code>Double c = new Double(&quot;-2.34&quot;); Integer i = new Integer(&quot;1234&quot;); </code></li>
</ul>
</li>
<li>已知字符串，可使用valueOf方法将其转换成包裹类对象<ul>
<li><code>Integer.valueOf(&quot;125&quot;); Double.valueOf(&quot;5.15&quot;);</code></li>
</ul>
</li>
</ul>
<p>自动装箱</p>
<p><code>Integer i =3; Double d = -5.25</code></p>
<p><strong>得到基本数据类型数据的方法</strong></p>
<p>每一个包裹类都提供相应的方法将包裹类对象转换回基本数据类型的数据</p>
<p><code>anIntegerObject.intValue() // 返回 int类 </code></p>
<p>``aCharacterObject.charValue() // 返回 char类型的数据`</p>
<p>Integer、Float、Double、Long、Byte及Short类提供了特殊的方法能够将字符串类型的对象直接转换成对应的int、float、double、long、byte或short类型的数据</p>
<p><code>Integer.parseInt(“234”) // 返回int类型的数据 </code></p>
<p><code>Float.parseFloat(“234.78”) // 返回float类型的数据</code></p>
<p>自动拆箱</p>
<p><code>Integer a = new Integer(3); int i = a;</code></p>
<h4 id="常量字符串类String"><a href="#常量字符串类String" class="headerlink" title="常量字符串类String"></a><strong>常量字符串类String</strong></h4><p>String类</p>
<ul>
<li>该类字符串对象的值和长度都不变化</li>
<li>称为常量字符串</li>
</ul>
<p>生成String类对象的方法</p>
<ul>
<li>可以这样生成一个常量字符串<ul>
<li><code>String aString; aString = “This is a string</code></li>
</ul>
</li>
<li>调用构造方法生成字符串对象<ul>
<li><code>new String();  </code></li>
<li><code>new String(String value);  </code></li>
<li><code>new String(char[] value);  </code></li>
<li><code>new String(char[] value, int offset, int count);  </code></li>
<li><code>new String(StringBuffer buffer);</code></li>
</ul>
</li>
</ul>
<p>String类的常用方法1</p>
<img src="D:\我的文件\Java课件\第四章 类的重用.assets\image-20210520203601464.png" alt="image-20210520203601464" style="zoom:80%;" / srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="D:\我的文件\Java课件\第四章 类的重用.assets\image-20210520203601464.png" class="lozad post-image">

<p>String类的常用方法2</p>
<img src="D:\我的文件\Java课件\第四章 类的重用.assets\image-20210520203704649.png" alt="image-20210520203704649" style="zoom:80%;" / srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="D:\我的文件\Java课件\第四章 类的重用.assets\image-20210520203704649.png" class="lozad post-image">

<h4 id="变量字符串类StringBuffer"><a href="#变量字符串类StringBuffer" class="headerlink" title="变量字符串类StringBuffer"></a>变量字符串类StringBuffer</h4><p>其对象是可以修改的字符串</p>
<ul>
<li>字符的个数称为对象的<strong>长度</strong></li>
<li>分配的存储空间成为对象的<strong>容量</strong></li>
</ul>
<p>与String类的对象相比，执行效率要低一些（要看具体情况）</p>
<p>该类的方法不能被用于String类的对象</p>
<p>生成StringBuffer类的对象</p>
<ul>
<li><code>new StringBuffer();</code>    生成容量为16的空字符串对象</li>
<li><code>new StringBuffer(int size);</code>    生成容量为size的空字符串对象</li>
<li><code>new StringBuffer(String aString)</code>    生成aString的一个备份，容量为其长度+16</li>
</ul>
<p>StringBuffer类的常用方法1</p>
<img src="D:\我的文件\Java课件\第四章 类的重用.assets\image-20210520204303630.png" alt="image-20210520204303630" style="zoom:80%;" / srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="D:\我的文件\Java课件\第四章 类的重用.assets\image-20210520204303630.png" class="lozad post-image">

<p>StringBuffer类的常用方法2</p>
<img src="D:\我的文件\Java课件\第四章 类的重用.assets\image-20210520204347416.png" alt="image-20210520204347416" style="zoom:80%;" / srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="D:\我的文件\Java课件\第四章 类的重用.assets\image-20210520204347416.png" class="lozad post-image">

<p><strong>StringBuilder不是线程安全的，比StringBuffer效率高，应该 尽可能使用。</strong> </p>
<p> 如果是需要大量的动态的操作字符串，应该选用StringBuffer 或者StringBuilder; 否则应该选用String</p>
<h4 id="数学类（Math）"><a href="#数学类（Math）" class="headerlink" title="数学类（Math）"></a>数学类（Math）</h4><p>提供一组常量和数学函数，例如</p>
<ul>
<li>E和PI常数 </li>
<li>求绝对值的abs方法 </li>
<li>计算三角函数的sin方法和cos方法 </li>
<li>求最小值、最大值的min方法和max方法 </li>
<li>求随机数的random方法等</li>
</ul>
<p>其中所有的变量和方法都是静态的</p>
<p>是终结类，不能从中派生其他的新类</p>
<h4 id="系统和运行时类-System、Runtime"><a href="#系统和运行时类-System、Runtime" class="headerlink" title="系统和运行时类(System、Runtime)"></a>系统和运行时类(System、Runtime)</h4><p>System类</p>
<ul>
<li>访问系统资源<ul>
<li><code>arraycopy()</code>        复制一个数组</li>
<li><code>exit()</code>        结束当前运行的程序</li>
<li><code>currentTimeMillis（）</code>        获得系统当前日期和时间等</li>
</ul>
</li>
<li>访问标准输入输出流<ul>
<li><code>System.in</code>     标准输入，表示键盘</li>
<li><code>System.out</code>   标准输出，表示显示器</li>
</ul>
</li>
</ul>
<p>Runtime类</p>
<ul>
<li>可直接访问运行时资源<ul>
<li><code>totalMemory()</code>    返回系统内存总量</li>
<li><code>freeMemory()</code>      返回内存的剩余空间</li>
</ul>
</li>
</ul>
<h4 id="类操作类（Class、ClassLoader）"><a href="#类操作类（Class、ClassLoader）" class="headerlink" title="类操作类（Class、ClassLoader）"></a>类操作类（Class、ClassLoader）</h4><p>Class类</p>
<ul>
<li>提供运行时信息，如名字、类型以及父类</li>
<li>Object类中的getClass方法返回当前对象所在 的类，返回类型是Class</li>
<li>它的getName方法返回一个类的名称，返回值 是String</li>
<li>它的getSuperclass方法可以获得当前对象的父 类</li>
</ul>
<p>ClassLoader类</p>
<ul>
<li>提供把类装入运行时环境的方法</li>
<li>构筑比较大型的复杂的系统时，可能会需要定义自己的ClassLoader</li>
</ul>
<h4 id="实用包"><a href="#实用包" class="headerlink" title="实用包"></a>实用包</h4><p>实用包(java.util)——实现各种不同实用功能</p>
<p>日期类：描述日期和时间</p>
<ul>
<li>Date</li>
<li>Calendar</li>
<li>GregorianCalendar</li>
</ul>
<p>集合类</p>
<ul>
<li>Collection（无序集合）、Set（不重复集合）</li>
<li>List（有序不重复集合）、Enumeration（枚举）</li>
<li>LinkedList（链表）、Vector（向量）</li>
<li>Stack（栈）、Hashtable（散列表）、TreeSet（树）</li>
</ul>
<p>StringTokenizer类</p>
<ul>
<li>允许以某种分隔标准将字符串分隔成单独的子字符串</li>
</ul>
<h4 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h4><p>构造方法</p>
<p>Date()    获得系统当前日期和时间值。</p>
<p>Date(long date)    以date创建日期对象，date表示从GMT时间1970-1-1 00：00：00开始至某时刻的毫秒数</p>
<p>常用方法</p>
<p><code>getTime</code>()`    返回一个长整型表示时间，单位为毫秒</p>
<p><code>after(Date d)</code>    返回接收者表示的日期是否在给定的日期之后</p>
<p><code>before(Date d)</code>    返回接收者表示的日期是否在给定的日期之前</p>
<h4 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h4><p>一个抽象的基础类，支持将Date对象转换成一系列单个的日期整型数据集，如YEAR、MONTH、DAY、HOUR等常量</p>
<p>它派生的 <code>GregorianCalendar</code>类实现标准的Gregorian日历</p>
<p>由于Calendar是抽象类，不能用new方法生成Calendar的实例对象，可以使用getInstance()方法创建一个GregorianCalendar类的对象</p>
<p>Calendar类中声明的常量</p>
<p><code>Calendar.SUNDAY  ▫ Calendar.MONDAY  ▫ Calendar.TUESDAY  ▫ Calendar.SATURDAY ▫ Calendar.JANUARY  ▫ Calendar.FEBRUARY  ▫ Calendar.AM  ▫ ...</code></p>
<p>Calendar类中的方法</p>
<pre class="highlight"><span class="line">▫ isLeapYear(int year) 返回给定的年份是否是润年</span><br><span class="line">▫ get(int field) 取得特定Calendar对象的信息</span><br><span class="line"> aCalendar.get(java.util.Calendar.YEAR); </span><br><span class="line"> aCalendar.get(java.util.Calendar.MONTH); </span><br><span class="line"> aCalendar.get(java.util.Calendar.DAY_OF_WEEK); </span><br><span class="line"> aCalendar.get(java.util.Calendar.MINUTE);</span><br><span class="line"> ...</span><br><span class="line">▫ set(int field, int value) 给日期域设定特定的值</span><br><span class="line"> aCalendar.set(Calendar.MONTH, Calendar.JANUARY); </span><br><span class="line"> aCalendar.set(1999, Calendar.AUGUST, 15); </span><br><span class="line"> ...</span><br></pre>

<h4 id="GregorianCalendar类"><a href="#GregorianCalendar类" class="headerlink" title="GregorianCalendar类"></a>GregorianCalendar类</h4><p><code>Java.util.GregorianCalendar类</code></p>
<p>用于查询及操作日期</p>
<pre class="highlight"><span class="line">▫ 构造方法</span><br><span class="line"> new GregorianCalendar() // 当前日期</span><br><span class="line"> new GregorianCalendar(1999, 11, 31) // 特定日期</span><br><span class="line"> new GregorianCalendar(1968, 0, 8, 11, 55) // 日期和时间</span><br><span class="line">▫ getTime()方法 返回Date对象，显示日历</span><br><span class="line"> System.out.println(new GregorianCalendar().getTime()); </span><br><span class="line"> System.out.println(new GregorianCalendar(1999, 11, </span><br><span class="line">31).getTime()); </span><br><span class="line"> System.out.println(new GregorianCalendar(1968, 0, 8, 11, </span><br><span class="line">55).getTime()); </span><br></pre>

<h4 id="StringTokenizer类"><a href="#StringTokenizer类" class="headerlink" title="StringTokenizer类"></a>StringTokenizer类</h4><p>允许以某种分隔标准将字符串分隔成单独的子字符串，如可以将单词从语句中分离出来</p>
<p>术语分隔符是指用于分隔单词（也成为标记，tokens）的字符</p>
<p>常用方法</p>
<p><code> int countTokens() 返回单词的个数 </code></p>
<p><code> String nextToken() 返回下一个单词 </code></p>
<p><code> boolean hasMoreTokens() 是否还有单词</code></p>
<p>生成StringTokennizer类对象的方法</p>
<p><code>new StringTokenizer（String aString）</code></p>
<ul>
<li>指定了将被处理的字符串，没有指定分隔符，这种情况下默认的分隔符为空格</li>
</ul>
<p><code>new StringTokenizer(String aString,String delimiters)</code></p>
<ul>
<li>除了指定将被处理的字符串，还制定了分隔符字符串，如分隔符字符串可以为“，：；|_()”</li>
</ul>
<p><code>new StringTokenizer(String aString, String  delimiters, boolean returnDelimiters);</code></p>
<ul>
<li>第三个参数如果为true，则分隔符本身也作为标记返回</li>
</ul>
<h4 id="文本包（java-text"><a href="#文本包（java-text" class="headerlink" title="文本包（java.text)"></a>文本包（java.text)</h4><p>包含</p>
<ul>
<li>Format类</li>
<li>DateFormat类</li>
<li>SimpleDateFormat类<ul>
<li>使用已定义的格式对日期对象进行格式化</li>
<li>构造方法  以一指定格式的字符串作为参数</li>
<li><code>new java.text.SimpleDateFormat(formatString);</code></li>
<li><code>format(Date d) 将此种格式应用于给定的日期 </code></li>
<li><code>aSimpleDateFormat.format(aDate);</code></li>
</ul>
</li>
</ul>
<h3 id="2-自定义包"><a href="#2-自定义包" class="headerlink" title="2.自定义包"></a>2.自定义包</h3><p>包是一组类的集合，利用包来管理类，可实现类的共享与复用</p>
<p>同一包中的类在默认情况下可以互相访问，通常把需要在一起工作的类放在一个包里</p>
<p>在实际使用中，用户可以将自己的类组织成包结构</p>
<h4 id="包的声明"><a href="#包的声明" class="headerlink" title="包的声明"></a>包的声明</h4><p>包名</p>
<ul>
<li>通常全部用小写字母</li>
<li>且每个包的名称都必须是<strong>独一无二的</strong>，为避免包名冲突，可将机构的Internet域名反序，作为包的前导</li>
</ul>
<p>声明语句</p>
<p><strong>package mypackage;</strong></p>
<ul>
<li>说明当前文件中声明的所有类都属于包mypackage </li>
<li>此文件中的每一个类名前都有前缀mypackage，即实际类名应该是mypackage.ClassName，因此不同包中的相同类名不会冲突</li>
</ul>
<p>package语句</p>
<ul>
<li>Java源文件的第一条语句，前面只能有注释或空行</li>
<li>一个文件中最多只能有一条</li>
<li>如果源文件没有，则文件中声明的所有类属于一个默认的无名包</li>
<li>包声明的语句的完整格式如下：<ul>
<li><code>package pkg1[.pkg2[.pkg3…]];</code></li>
<li>Java编译器把包对应于文件系统的目录结构</li>
<li>用点来指明目录的层次</li>
</ul>
</li>
</ul>
<h4 id="编译和生成包"><a href="#编译和生成包" class="headerlink" title="编译和生成包"></a>编译和生成包</h4><p>如果在程序Test.java中已声明了包mypackage</p>
<ul>
<li>编译时采用方式<code> javac -d destpath Test.java</code></li>
<li>则编译器会自动在destpath目录下建立子目录mypackage，并将 生成的.class文件都放到destpath/mypackage下。</li>
</ul>
<h2 id="八、本章小结"><a href="#八、本章小结" class="headerlink" title="八、本章小结"></a>八、本章小结</h2><p>本章内容 </p>
<ul>
<li>介绍了Java语言类的重用机制，形式可以是组合或继承 </li>
<li>Object类的主要方法 </li>
<li>终结类和终结方法的特点和语法 </li>
<li>抽象类和抽象方法的特点和语法 </li>
<li>Java基础类库的一些重要的类 </li>
</ul>
<p>本章要求 </p>
<ul>
<li>理解组合和继承的区别，能够知道何时使用那种方法 </li>
<li>了解终结类、终结方法、抽象类、抽象方法的概念 </li>
<li> 熟练掌握本章提到的Java基础类库中的一些常见类</li>
</ul>

  </div>
  <div>
    
      <div 
        class="post-note note-warning copyright" 
        style="margin-top: 42px">
        <p>
          <span style="font-weight: bold;">作者：</span><a 
            target="_blank" 
            rel="nofollow noopener noreferrer" 
            href="/about">
            xuehongfei
          </a>
        </p>
        <p>
          <span style="font-weight: bold;">文章链接：</span><a 
            target="_blank" 
            rel="nofollow noopener noreferrer" 
            href="http://example.com/2021/08/05/04-%E7%B1%BB%E7%9A%84%E9%87%8D%E7%94%A8/">
            http://example.com/2021/08/05/04-%E7%B1%BB%E7%9A%84%E9%87%8D%E7%94%A8/
          </a>
        </p>
        <p><span style="font-weight: bold;">版权声明：</span>本博客所有文章除特别声明外，均采用<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0 协议</a>。转载请注明出处！</p>
      </div>
    
  </div>
</article>
<div class="nav">
  
    <div class="nav-item-prev">
      <a 
        href="/2021/08/05/05-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%A4%9A%E6%80%81/" 
        class="nav-link">
        <i class="iconfont icon-left nav-prev-icon"></i>
        <div>
          <div class="nav-label">Prev</div>
          
            <div class="nav-title">05 接口与多态 </div>
          
        </div>
      </a>
    </div>
  
  
    <div class="nav-item-next">
      <a 
        href="/2021/08/05/03-%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/" 
        class="nav-link">
        <div>
          <div class="nav-label">Next</div>
          
            <div class="nav-title">03 类中的方法 </div>
          
        </div>
        <i class="iconfont icon-right nav-next-icon"></i>
      </a>
    </div>
  
</div>

<div 
  class="card card-content toc-card" 
  id="mobiletoc">
  <div class="toc-header">
  <i 
    class="iconfont icon-menu" 
    style="padding-right: 2px;">
  </i>TOC
</div>
<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%B1%BB%E7%9A%84%E9%87%8D%E7%94%A8"><span class="toc-text">第四章 类的重用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-text">一、类的继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">1.继承的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%B1%BB%E5%92%8C%E6%B4%BE%E7%94%9F%E7%B1%BB"><span class="toc-text">基类和派生类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="toc-text">派生类对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BB%A7%E6%89%BF%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-text">2.继承的语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%9A%90%E8%97%8F%E5%92%8C%E8%A6%86%E7%9B%96"><span class="toc-text">3.隐藏和覆盖</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E7%9A%84%E9%9A%90%E8%97%8F"><span class="toc-text">属性的隐藏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E8%A2%AB%E9%9A%90%E8%97%8F%E7%9A%84%E7%88%B6%E7%B1%BB%E5%B1%9E%E6%80%A7"><span class="toc-text">访问被隐藏的父类属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Review"><span class="toc-text">Review</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96"><span class="toc-text">方法覆盖</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%9C%89%E7%BB%A7%E6%89%BF%E6%97%B6%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-text">4.有继承时的构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%BB%A7%E6%89%BF%E4%B8%BE%E4%BE%8B"><span class="toc-text">5.继承举例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Object%E7%B1%BB"><span class="toc-text">二、Object类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E5%90%AB%E7%9A%84%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95"><span class="toc-text">包含的主要方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E7%AD%89%E5%92%8C%E5%90%8C%E4%B8%80"><span class="toc-text">相等和同一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#equals%E6%96%B9%E6%B3%95"><span class="toc-text">equals方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-pool"><span class="toc-text">String pool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clone%E6%96%B9%E6%B3%95"><span class="toc-text">clone方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#finalize-%E6%96%B9%E6%B3%95"><span class="toc-text">finalize()方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getClass%E6%96%B9%E6%B3%95"><span class="toc-text">getClass方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#notify%E3%80%81notifyAll%E3%80%81wait%E6%96%B9%E6%B3%95"><span class="toc-text">notify、notifyAll、wait方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%BB%88%E7%BB%93%E7%B1%BB%E4%B8%8E%E7%BB%88%E7%BB%93%E6%96%B9%E6%B3%95"><span class="toc-text">三、终结类与终结方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BB%88%E7%BB%93%E7%B1%BB"><span class="toc-text">1.终结类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BB%88%E7%BB%93%E6%96%B9%E6%B3%95"><span class="toc-text">2.终结方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Review-1"><span class="toc-text">Review</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-text">四、抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-text">1.抽象类的声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-text">2.抽象方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">需注意的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-text">抽象方法的优点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%B3%9B%E5%9E%8B"><span class="toc-text">五、泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%B3%9B%E5%9E%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">1.泛型的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%80%9A%E9%85%8D%E7%AC%A6%E6%B3%9B%E5%9E%8B%E5%92%8C%E6%9C%89%E9%99%90%E5%88%B6%E7%9A%84%E6%B3%9B%E5%9E%8B"><span class="toc-text">2.通配符泛型和有限制的泛型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E7%B1%BB%E7%9A%84%E7%BB%84%E5%90%88"><span class="toc-text">六、类的组合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BB%84%E5%90%88%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-text">1.组合的语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">2.组合与继承的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF%E7%9A%84%E7%BB%93%E5%90%88"><span class="toc-text">3.组合与继承的结合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-text">面向对象设计原则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%8C%85%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">七、包的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Java%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%BA%93"><span class="toc-text">1.Java基础类库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E8%A8%80%E5%8C%85%EF%BC%88java-lang"><span class="toc-text">语言包（java.lang)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8C%85%E8%A3%B9%E7%B1%BB"><span class="toc-text">数据类型包裹类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BBString"><span class="toc-text">常量字符串类String</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BBStringBuffer"><span class="toc-text">变量字符串类StringBuffer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E7%B1%BB%EF%BC%88Math%EF%BC%89"><span class="toc-text">数学类（Math）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB-System%E3%80%81Runtime"><span class="toc-text">系统和运行时类(System、Runtime)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%93%8D%E4%BD%9C%E7%B1%BB%EF%BC%88Class%E3%80%81ClassLoader%EF%BC%89"><span class="toc-text">类操作类（Class、ClassLoader）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%94%A8%E5%8C%85"><span class="toc-text">实用包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Date%E7%B1%BB"><span class="toc-text">Date类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Calendar%E7%B1%BB"><span class="toc-text">Calendar类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GregorianCalendar%E7%B1%BB"><span class="toc-text">GregorianCalendar类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StringTokenizer%E7%B1%BB"><span class="toc-text">StringTokenizer类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E5%8C%85%EF%BC%88java-text"><span class="toc-text">文本包（java.text)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8C%85"><span class="toc-text">2.自定义包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-text">包的声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%92%8C%E7%94%9F%E6%88%90%E5%8C%85"><span class="toc-text">编译和生成包</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93"><span class="toc-text">八、本章小结</span></a></li></ol></li></ol>
</div></main>
            <aside class="left-column">
              
              <div class="card card-author">
                
  <img 
    src="img/catton.jpg" 
    class="author-img"
    width="88"
    height="88"
    alt="author avatar">

<p class="author-name">xuehongfei</p>
<p class="author-description">designed by Mr.Xue</p>
<div class="author-message">
  <a 
    class="author-posts-count" 
    href="/archives">
    <span>9</span>
    <span>Posts</span>
  </a>
  <a 
    class="author-categories-count" 
    href="/categories">
    <span>0</span>
    <span>Categories</span>
  </a>
  <a 
    class="author-tags-count" 
    href="/tags">
    <span>0</span>
    <span>Tags</span>
  </a>
</div>

              </div>
               <div class="sticky-tablet">
  
  
    <article class="display-when-two-columns spacer">
      <div class="card card-content toc-card">
        <div class="toc-header">
  <i 
    class="iconfont icon-menu" 
    style="padding-right: 2px;">
  </i>TOC
</div>
<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%B1%BB%E7%9A%84%E9%87%8D%E7%94%A8"><span class="toc-text">第四章 类的重用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-text">一、类的继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">1.继承的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%B1%BB%E5%92%8C%E6%B4%BE%E7%94%9F%E7%B1%BB"><span class="toc-text">基类和派生类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="toc-text">派生类对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BB%A7%E6%89%BF%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-text">2.继承的语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%9A%90%E8%97%8F%E5%92%8C%E8%A6%86%E7%9B%96"><span class="toc-text">3.隐藏和覆盖</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E7%9A%84%E9%9A%90%E8%97%8F"><span class="toc-text">属性的隐藏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E8%A2%AB%E9%9A%90%E8%97%8F%E7%9A%84%E7%88%B6%E7%B1%BB%E5%B1%9E%E6%80%A7"><span class="toc-text">访问被隐藏的父类属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Review"><span class="toc-text">Review</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96"><span class="toc-text">方法覆盖</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%9C%89%E7%BB%A7%E6%89%BF%E6%97%B6%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-text">4.有继承时的构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%BB%A7%E6%89%BF%E4%B8%BE%E4%BE%8B"><span class="toc-text">5.继承举例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Object%E7%B1%BB"><span class="toc-text">二、Object类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E5%90%AB%E7%9A%84%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95"><span class="toc-text">包含的主要方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E7%AD%89%E5%92%8C%E5%90%8C%E4%B8%80"><span class="toc-text">相等和同一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#equals%E6%96%B9%E6%B3%95"><span class="toc-text">equals方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-pool"><span class="toc-text">String pool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clone%E6%96%B9%E6%B3%95"><span class="toc-text">clone方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#finalize-%E6%96%B9%E6%B3%95"><span class="toc-text">finalize()方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getClass%E6%96%B9%E6%B3%95"><span class="toc-text">getClass方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#notify%E3%80%81notifyAll%E3%80%81wait%E6%96%B9%E6%B3%95"><span class="toc-text">notify、notifyAll、wait方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%BB%88%E7%BB%93%E7%B1%BB%E4%B8%8E%E7%BB%88%E7%BB%93%E6%96%B9%E6%B3%95"><span class="toc-text">三、终结类与终结方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BB%88%E7%BB%93%E7%B1%BB"><span class="toc-text">1.终结类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BB%88%E7%BB%93%E6%96%B9%E6%B3%95"><span class="toc-text">2.终结方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Review-1"><span class="toc-text">Review</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-text">四、抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-text">1.抽象类的声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-text">2.抽象方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">需注意的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-text">抽象方法的优点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%B3%9B%E5%9E%8B"><span class="toc-text">五、泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%B3%9B%E5%9E%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">1.泛型的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%80%9A%E9%85%8D%E7%AC%A6%E6%B3%9B%E5%9E%8B%E5%92%8C%E6%9C%89%E9%99%90%E5%88%B6%E7%9A%84%E6%B3%9B%E5%9E%8B"><span class="toc-text">2.通配符泛型和有限制的泛型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E7%B1%BB%E7%9A%84%E7%BB%84%E5%90%88"><span class="toc-text">六、类的组合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BB%84%E5%90%88%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-text">1.组合的语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">2.组合与继承的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF%E7%9A%84%E7%BB%93%E5%90%88"><span class="toc-text">3.组合与继承的结合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-text">面向对象设计原则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%8C%85%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">七、包的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Java%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%BA%93"><span class="toc-text">1.Java基础类库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E8%A8%80%E5%8C%85%EF%BC%88java-lang"><span class="toc-text">语言包（java.lang)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8C%85%E8%A3%B9%E7%B1%BB"><span class="toc-text">数据类型包裹类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BBString"><span class="toc-text">常量字符串类String</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BBStringBuffer"><span class="toc-text">变量字符串类StringBuffer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E7%B1%BB%EF%BC%88Math%EF%BC%89"><span class="toc-text">数学类（Math）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB-System%E3%80%81Runtime"><span class="toc-text">系统和运行时类(System、Runtime)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%93%8D%E4%BD%9C%E7%B1%BB%EF%BC%88Class%E3%80%81ClassLoader%EF%BC%89"><span class="toc-text">类操作类（Class、ClassLoader）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%94%A8%E5%8C%85"><span class="toc-text">实用包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Date%E7%B1%BB"><span class="toc-text">Date类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Calendar%E7%B1%BB"><span class="toc-text">Calendar类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GregorianCalendar%E7%B1%BB"><span class="toc-text">GregorianCalendar类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StringTokenizer%E7%B1%BB"><span class="toc-text">StringTokenizer类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E5%8C%85%EF%BC%88java-text"><span class="toc-text">文本包（java.text)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8C%85"><span class="toc-text">2.自定义包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-text">包的声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%92%8C%E7%94%9F%E6%88%90%E5%8C%85"><span class="toc-text">编译和生成包</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93"><span class="toc-text">八、本章小结</span></a></li></ol></li></ol>
      </div>
    </article>
  
  
  <article class="card card-content categories-widget">
    <div class="categories-card">
  <div class="categories-header">
    <i 
      class="iconfont icon-fenlei" 
      style="padding-right: 2px;">
    </i>Categories
  </div>
  <div class="categories-list">
    
  </div>
</div>
  </article>
  
  <article class="card card-content tags-widget">
    <div class="tags-card">
  <div class="tags-header">
    <i 
      class="iconfont icon-biaoqian" 
      style="padding-right: 2px;">
    </i>hot tags
  </div>
  <div class="tags-list">
    
  </div>
</div>
  </article>
  
  
</div>
            </aside>
            <aside class="right-column">
              <div class="sticky-widescreen">
  
  
    <article class="card card-content toc-card">
      <div class="toc-header">
  <i 
    class="iconfont icon-menu" 
    style="padding-right: 2px;">
  </i>TOC
</div>
<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%B1%BB%E7%9A%84%E9%87%8D%E7%94%A8"><span class="toc-text">第四章 类的重用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-text">一、类的继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">1.继承的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%B1%BB%E5%92%8C%E6%B4%BE%E7%94%9F%E7%B1%BB"><span class="toc-text">基类和派生类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="toc-text">派生类对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BB%A7%E6%89%BF%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-text">2.继承的语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%9A%90%E8%97%8F%E5%92%8C%E8%A6%86%E7%9B%96"><span class="toc-text">3.隐藏和覆盖</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E7%9A%84%E9%9A%90%E8%97%8F"><span class="toc-text">属性的隐藏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E8%A2%AB%E9%9A%90%E8%97%8F%E7%9A%84%E7%88%B6%E7%B1%BB%E5%B1%9E%E6%80%A7"><span class="toc-text">访问被隐藏的父类属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Review"><span class="toc-text">Review</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96"><span class="toc-text">方法覆盖</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%9C%89%E7%BB%A7%E6%89%BF%E6%97%B6%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-text">4.有继承时的构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%BB%A7%E6%89%BF%E4%B8%BE%E4%BE%8B"><span class="toc-text">5.继承举例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Object%E7%B1%BB"><span class="toc-text">二、Object类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E5%90%AB%E7%9A%84%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95"><span class="toc-text">包含的主要方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E7%AD%89%E5%92%8C%E5%90%8C%E4%B8%80"><span class="toc-text">相等和同一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#equals%E6%96%B9%E6%B3%95"><span class="toc-text">equals方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-pool"><span class="toc-text">String pool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clone%E6%96%B9%E6%B3%95"><span class="toc-text">clone方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#finalize-%E6%96%B9%E6%B3%95"><span class="toc-text">finalize()方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getClass%E6%96%B9%E6%B3%95"><span class="toc-text">getClass方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#notify%E3%80%81notifyAll%E3%80%81wait%E6%96%B9%E6%B3%95"><span class="toc-text">notify、notifyAll、wait方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%BB%88%E7%BB%93%E7%B1%BB%E4%B8%8E%E7%BB%88%E7%BB%93%E6%96%B9%E6%B3%95"><span class="toc-text">三、终结类与终结方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BB%88%E7%BB%93%E7%B1%BB"><span class="toc-text">1.终结类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BB%88%E7%BB%93%E6%96%B9%E6%B3%95"><span class="toc-text">2.终结方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Review-1"><span class="toc-text">Review</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-text">四、抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-text">1.抽象类的声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-text">2.抽象方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">需注意的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-text">抽象方法的优点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%B3%9B%E5%9E%8B"><span class="toc-text">五、泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%B3%9B%E5%9E%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">1.泛型的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%80%9A%E9%85%8D%E7%AC%A6%E6%B3%9B%E5%9E%8B%E5%92%8C%E6%9C%89%E9%99%90%E5%88%B6%E7%9A%84%E6%B3%9B%E5%9E%8B"><span class="toc-text">2.通配符泛型和有限制的泛型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E7%B1%BB%E7%9A%84%E7%BB%84%E5%90%88"><span class="toc-text">六、类的组合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BB%84%E5%90%88%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-text">1.组合的语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">2.组合与继承的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF%E7%9A%84%E7%BB%93%E5%90%88"><span class="toc-text">3.组合与继承的结合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-text">面向对象设计原则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%8C%85%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">七、包的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Java%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%BA%93"><span class="toc-text">1.Java基础类库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E8%A8%80%E5%8C%85%EF%BC%88java-lang"><span class="toc-text">语言包（java.lang)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8C%85%E8%A3%B9%E7%B1%BB"><span class="toc-text">数据类型包裹类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BBString"><span class="toc-text">常量字符串类String</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BBStringBuffer"><span class="toc-text">变量字符串类StringBuffer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E7%B1%BB%EF%BC%88Math%EF%BC%89"><span class="toc-text">数学类（Math）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB-System%E3%80%81Runtime"><span class="toc-text">系统和运行时类(System、Runtime)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%93%8D%E4%BD%9C%E7%B1%BB%EF%BC%88Class%E3%80%81ClassLoader%EF%BC%89"><span class="toc-text">类操作类（Class、ClassLoader）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%94%A8%E5%8C%85"><span class="toc-text">实用包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Date%E7%B1%BB"><span class="toc-text">Date类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Calendar%E7%B1%BB"><span class="toc-text">Calendar类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GregorianCalendar%E7%B1%BB"><span class="toc-text">GregorianCalendar类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StringTokenizer%E7%B1%BB"><span class="toc-text">StringTokenizer类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E5%8C%85%EF%BC%88java-text"><span class="toc-text">文本包（java.text)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8C%85"><span class="toc-text">2.自定义包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-text">包的声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%92%8C%E7%94%9F%E6%88%90%E5%8C%85"><span class="toc-text">编译和生成包</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93"><span class="toc-text">八、本章小结</span></a></li></ol></li></ol>
    </article>
  
  
  <article class="card card-content">
    <div class="recent-posts-card">
  <div class="recent-posts-header">
    <i 
      class="iconfont icon-wenzhang_huaban" 
      style="padding-right: 2px;">
    </i>Recent Posts
  </div>
  <div class="recent-posts-list">
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2021-08-17</div>
        <a href="/2021/08/17/%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E5%99%A8/"><div class="recent-posts-item-content">运算方法与运算器</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2021-08-17</div>
        <a href="/2021/08/17/%E6%95%B0%E5%80%BC%E6%95%B0%E6%8D%AE/"><div class="recent-posts-item-content">数值数据</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2021-08-05</div>
        <a href="/2021/08/05/05-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%A4%9A%E6%80%81/"><div class="recent-posts-item-content">05 接口与多态</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2021-08-05</div>
        <a href="/2021/08/05/04-%E7%B1%BB%E7%9A%84%E9%87%8D%E7%94%A8/"><div class="recent-posts-item-content">04 类的重用</div></a>
      </div>
    
  </div>
</div>
  </article>
  
  
</div>
            </aside>
          </div>
        </div>
      </div>
    </div>
     
    <footer class="footer">
  <div class="footer-container">
    <div>
      <div class="footer-dsc">
        <span>
          Copyright ©
          
            2020 -
          
          2021
        </span>
        &nbsp;
        <a 
          href="/" 
          class="footer-link">
          Mr.Xue's Blog
        </a>
      </div>
    </div>

    
      <div class="footer-dsc">
        
          Powered by
          <a 
            href="https://hexo.io/" 
            class="footer-link" 
            target="_blank" 
            rel="nofollow noopener noreferrer">
            &nbsp;Hexo
          </a>
        
        
          <span>&nbsp;|&nbsp;</span>
        
        
          Theme -
          <a 
            href="https://github.com/theme-kaze" 
            class="footer-link" 
            target="_blank"
            rel="nofollow noopener noreferrer">
            &nbsp;Kaze
          </a>
        
      </div>
    
    
    
    
</footer> 
    
  <a 
    role="button" 
    id="scrollbutton" 
    class="basebutton" 
    aria-label="回到顶部">
    <i class="iconfont icon-arrowleft button-icon"></i>
  </a>

<a 
  role="button" 
  id="menubutton"
  aria-label="menu button"
  class="basebutton">
  <i class="iconfont icon-menu button-icon"></i>
</a>
<a 
  role="button" 
  id="popbutton" 
  class="basebutton" 
  aria-label="控制中心">
  <i class="iconfont icon-expand button-icon"></i>
</a>
<a 
  role="button" 
  id="darkbutton" 
  class="basebutton darkwidget" 
  aria-label="夜色模式">
  <i class="iconfont icon-weather button-icon"></i>
</a>
<a 
  role="button" 
  id="searchbutton" 
  class="basebutton searchwidget" 
  aria-label="搜索">
  <i class="iconfont icon-search button-icon"></i>
</a> 
     
     
     
      <script>
  var addImgLayout = function () {
    var img = document.querySelectorAll('.post-content img')
    var i
    for (i = 0; i < img.length; i++) {
      var wrapper = document.createElement('a')
      wrapper.setAttribute('href', img[i].getAttribute('data-src'))
      wrapper.setAttribute('aria-label', 'illustration')
      wrapper.style.cssText =
        'width: 100%; display: flex; justify-content: center;'
      if (img[i].alt) wrapper.dataset.caption = img[i].alt
      wrapper.dataset.nolink = true
      img[i].before(wrapper)
      wrapper.append(img[i])
      var divWrap = document.createElement('div')
      divWrap.classList.add('gallery')
      wrapper.before(divWrap)
      divWrap.append(wrapper)
    }
    baguetteBox.run('.gallery')
  }
</script>
<script>
  loadScript(
    "/js/lib/lightbox/baguetteBox.min.js",
    addImgLayout
  )
</script>
 
     
     
    <script src="/js/main.js"></script> 
     
    
      <script>
        var addLazyload = function () {
          var observer = lozad('.lozad', {
            load: function (el) {
              el.srcset = el.getAttribute('data-src')
            },
            loaded: function (el) {
              el.classList.add('loaded')
            },
          })
          observer.observe()
        }
      </script>
      <script>
        loadScript('/js/lib/lozad.min.js', addLazyload)
      </script>
     
    
    
  </body>
</html>
